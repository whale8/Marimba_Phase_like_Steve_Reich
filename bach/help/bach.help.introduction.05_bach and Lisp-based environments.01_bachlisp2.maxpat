{
	"patcher" : 	{
		"fileversion" : 1,
		"appversion" : 		{
			"major" : 6,
			"minor" : 1,
			"revision" : 2,
			"architecture" : "x86"
		}
,
		"rect" : [ 548.0, 66.0, 617.0, 539.0 ],
		"bglocked" : 0,
		"openinpresentation" : 0,
		"default_fontsize" : 12.0,
		"default_fontface" : 0,
		"default_fontname" : "Arial",
		"gridonopen" : 0,
		"gridsize" : [ 15.0, 15.0 ],
		"gridsnaponopen" : 0,
		"statusbarvisible" : 2,
		"toolbarvisible" : 1,
		"boxanimatetime" : 200,
		"imprint" : 0,
		"enablehscroll" : 1,
		"enablevscroll" : 1,
		"devicewidth" : 0.0,
		"description" : "",
		"digest" : "",
		"tags" : "",
		"boxes" : [ 			{
				"box" : 				{
					"fontname" : "Arial",
					"fontsize" : 13.0,
					"id" : "obj-3",
					"linecount" : 9,
					"maxclass" : "bach.hypercomment",
					"numinlets" : 1,
					"numoutlets" : 1,
					"outlettype" : [ "" ],
					"patching_rect" : [ 6.0, 39.0, 589.0, 137.0 ],
					"sendto" : "bach.help.filtertags",
					"text" : "The most notable differences between Lisp-based environments and bach come directly from the different programming paradigms. For example, OM's sequence and cond would have no meaning within Max - you may think of trigger and gate as their maxian cousins. Iterations (i.e. mapcar, omloop, etc.) are generally obtained with bach.iter, bach.step and bach.collect, but the syntax is quite different - of course, uzi can be a powerful ally, too. Lambda functions do not exist, but some bach objects (e.g. bach.sort and bach.find, see #lambda) provide a feedback mechanism allowing you to implement custom comparison algorithms. The concept of class is unknown to bach. The only new data type is the llll, and complex data such as scores are simply specialized representations of specifically-structured lllls.",
					"textcolor" : [ 0.25, 0.25, 0.25, 1.0 ]
				}

			}
, 			{
				"box" : 				{
					"fontname" : "Arial",
					"fontsize" : 13.0,
					"frgb" : 0.0,
					"id" : "obj-5",
					"linecount" : 3,
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 6.0, 408.0, 589.0, 50.0 ],
					"text" : "All this has been the subject of a lot of careful thinking, and each of these choices has been made with the goal of a seamless integration of bach within the Max ecology. We hope you get used to the differences.",
					"textcolor" : [ 0.25, 0.25, 0.25, 1.0 ]
				}

			}
, 			{
				"box" : 				{
					"fontname" : "Arial",
					"fontsize" : 13.0,
					"frgb" : 0.0,
					"id" : "obj-2",
					"linecount" : 6,
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 6.0, 314.0, 589.0, 94.0 ],
					"text" : "The general rule, of course, is remembering that you're not working in OM or Lisp. The llll itself is conceptually very different from a Lisp list. You never \"touch\" the cons cells (even though they exist somewhere), the rules for parentheses are significantly different, you don't even have a distinction between atoms and one-element lists. At the same time, Lisp is a real, full-fledged programming language, while bach is not. If you want to build a very complex program, probably bach is not the right tool.",
					"textcolor" : [ 0.25, 0.25, 0.25, 1.0 ]
				}

			}
, 			{
				"box" : 				{
					"fontname" : "Arial",
					"fontsize" : 13.0,
					"frgb" : 0.0,
					"id" : "obj-1",
					"linecount" : 9,
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 6.0, 177.0, 589.0, 137.0 ],
					"text" : "Finally, there is no distinction between destructive and non-destructive operations. lllls are always passed by value, which means that if an object A outputs an llll x to two objects B (evaluated first) and C (evaluated later), in no occasion an operation performed on B will alter x as it is received and operated upon by C; nor x will ever be altered as it is re-sent from A, as long as A doesn't produce a different llll to send out. In fact, lllls behave just like any other Max datum (with the exception of Jitter matrices, of course): if you think of A as a number box, B as +, C as * and x as 5, you would never expect the number C to receive something different than 5 just because B has performed a sum upon it. The sum does not affect neither the number stored in A, nor the number received by C. As a consequence, no explicit clone operation exist.",
					"textcolor" : [ 0.25, 0.25, 0.25, 1.0 ]
				}

			}
, 			{
				"box" : 				{
					"fontname" : "Arial",
					"fontsize" : 11.0,
					"frgb" : 0.0,
					"id" : "obj-11",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 6.0, 514.0, 585.0, 19.0 ],
					"text" : "See Also: lambda",
					"textcolor" : [ 0.5, 0.5, 0.5, 1.0 ],
					"varname" : "seealso"
				}

			}
, 			{
				"box" : 				{
					"fontname" : "Arial",
					"fontsize" : 11.0,
					"frgb" : 0.0,
					"id" : "obj-10",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 6.0, 495.0, 585.0, 19.0 ],
					"text" : "Objects: all",
					"textcolor" : [ 0.5, 0.5, 0.5, 1.0 ],
					"varname" : "objects"
				}

			}
, 			{
				"box" : 				{
					"fontface" : 1,
					"fontname" : "Arial",
					"fontsize" : 15.0,
					"frgb" : 0.0,
					"id" : "obj-13",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 6.0, 7.0, 412.0, 23.0 ],
					"text" : "Notable differences",
					"varname" : "title"
				}

			}
, 			{
				"box" : 				{
					"fontname" : "Arial",
					"fontsize" : 11.0,
					"frgb" : 0.0,
					"id" : "obj-12",
					"maxclass" : "comment",
					"numinlets" : 1,
					"numoutlets" : 0,
					"patching_rect" : [ 6.0, 476.0, 585.0, 19.0 ],
					"text" : "Tags: introduction, bach, lisp, environment, open, music, openmusic, pwgl",
					"textcolor" : [ 0.5, 0.5, 0.5, 1.0 ],
					"varname" : "tags"
				}

			}
 ],
		"lines" : [  ],
		"dependency_cache" : [ 			{
				"name" : "bach.hypercomment.mxo",
				"type" : "iLaX"
			}
 ]
	}

}
