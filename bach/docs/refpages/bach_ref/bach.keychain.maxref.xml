<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<!--This file has been automatically generated by Doctor Max. DO NOT EDIT THIS FILE DIRECTLY.-->

<c74object name="bach.keychain" module="bach" kind="patcher">

	<digest>
		Organize lllls by keys
	</digest>

	<description>
		Classifies the elements of the incoming llll, by associating them with corresponding keys,
		and then by outputting the llll organized by keys.
	</description>

	<!--METADATA-->
	<metadatalist>
		<metadata name="author">bachproject</metadata>
		<metadata name="tag">bach</metadata>
		<metadata name="tag">bach abstractions</metadata>
		<metadata name="tag">bach llll</metadata>
	</metadatalist>

	<!--INLETS-->
	<inletlist>
		<inlet id="0" type="INLET_TYPE">
			<digest>
				The llll to be organized
			</digest>
			<description>
			</description>
		</inlet>
		<inlet id="1" type="INLET_TYPE">
			<digest>
				Lambda inlet
			</digest>
			<description>
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</inlet>
	</inletlist>

	<!--OUTLETS-->
	<outletlist>
		<outlet id="0" type="INLET_TYPE">
			<digest>
				The organized llll
			</digest>
			<description>
			</description>
		</outlet>
		<outlet id="1" type="INLET_TYPE">
			<digest>
				Lambda outlet
			</digest>
			<description>
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from the lambda outlet may be customly modified, so that such modification will be taken into
				account by the algorithm. To modify each element, just use patching and then plug into the lambda inlet the
				modified version of the element. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</outlet>
	</outletlist>

	<!--ARGUMENTS-->
	<objarglist>
	</objarglist>

	<!--MESSAGES-->
	<methodlist>
		<method name="bang">
			<arglist />
			<digest>
				Organize and output llll
			</digest>
			<description>
				Organize and outpu the most recently received input llll.
			</description>
		</method>
		<method name="llll">
			<arglist />
			<digest>
				Organize and output llll
			</digest>
			<description>
				An <m>llll</m> in the left inlet is considered the llll to be organised.
				Elements are output one by one from the right outlet, so that the user can retrieve their
				corresponding keys. Once the keys are re-injected, all the incoming llll is classified
				by keys. The output llll has the form <b>(<m>key1</m> <m>ELEM11</m> <m>ELEM12</m>...)
				(<m>key2</m> <m>ELEM21</m> <m>ELEM22</m>...)</b>, where all the <m>ELEM</m>s are the original
				elements of the list having the corresponding keys. Of course, each element shows up
				in the final list as many times as the number of its keys. <br />
				An llll in the second inlet is considered to be the "answer" of the lambda loop.
				Indeed second inlet is a lambda inlet. <br />
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</method>
	</methodlist>

	<!--ATTRIBUTES-->
	<attributelist>
		<attribute name="out" get="1" set="1" type="symbol" size="1">
			<digest>
				Outlet Types
			</digest>
			<description>
				The <m>out</m> attribute is a sequence of characters identifying the outlet types (one character for each llll outlet). Characters can be one of the followings: <br />
				<m>n</m> (default): 'native' output: faster and more precise between bach objects, but unreadable by standard Max objects (an "bach.llll" message appears instead). <br />
				<m>t</m>: 'text' output: slower and limited in size, but readable by standard Max objects. A plain llll in text format is a generic Max message. <br />
				<m>x</m>: disabled output (nothing is output) <br />
				<m>p</m>: 'portal' output: only used by bach.portal to intercept the @out attribute specified while creating the abstraction (see bach.portal). <br />
				The native output is recommended, unless communication with standard Max messages is needed. Disabling unused outputs can be useful if extreme optimization of the patch is needed.
				<br /> <br />
			</description>
			<attributelist>
				<attribute name="category" get="1" set="1" type="symbol" size="1" value="Behavior" />
				<attribute name="label" get="1" set="1" type="symbol" size="1" value="Outlet Types" />
				<attribute name="paint" get="1" set="1" type="int" size="1" value="1" />
				<attribute name="style" get="1" set="1" type="symbol" size="1" value="text" />
			</attributelist>
		</attribute>
	</attributelist>

	<!--SEEALSO-->
	<seealsolist>
		<seealso name="bach.keys" />
	</seealsolist>

	<misc name = "Input">
		<entry name ="Inlet 1 (llll)">
			<description>
				The llll to be organized.
			</description>
		</entry>
		<entry name ="Inlet 2 (llll)">
			<description>
				Lambda inlet.
				A lambda inlet is an inlet receiving the answer from a test or modification performed on elements sent out the lambda outlets. <br />
				In this case, the answer is expected to be a modification of the elements which had been sent out:
				the element output via the lambda outlet can be customly modified and then plugged in into this lambda inlet:
				such modification will be accounted for by the algorithm. <br />
				The lambda inlet also accepts the result in llll form, so you can sometimes avoid the explicit @out t. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
	</misc>

	<misc name = "Output">
		<entry name ="Outlet 1 (llll)">
			<description>
				The organized llll.
			</description>
		</entry>
		<entry name ="Outlet 2 (llll)">
			<description>
				Lambda outlet.
				A lambda outlet is an outlet outputting an element on which some test or modification must be performed.
				The result of the test or modification is then expected in a lambda inlet. <br />
				In this case, the elements output from the lambda outlet may be customly modified, so that such modification will be taken into
				account by the algorithm. To modify each element, just use patching and then plug into the lambda inlet the
				modified version of the element. <br />
				It is important to know that the evaluation chain inside the lambda loop must be direct: you can't use objects such as <o>delay</o>,
				<o>pipe</o>, <o>defer</o>; nor store the value anywhere waiting for some other event to trigger it. Also see #lambda in the bach Help Center.
				<br /> <br />
			</description>
		</entry>
	</misc>

</c74object>